深入理解X25519
longcpp
2019-09-02

Curve25519是Bernstein在2006年构建的蒙哥马利曲线,其中25519表示椭圆曲线所依赖的底层素数域的特征为2^255-19.基于曲线Curve25519, Bernstein构建了Diffie-Hellman密钥交换协议X25519.与传统的ECDH密钥交换协议相比, X25519协议最显著的特点是仅依赖椭圆曲线上点的x坐标. 这种仅利用x坐标构建ECDH密钥交换协议的想法最初来自于Victor Millier在1985年发表的奠基性文章”Use of elliptic curves in cryptography”.
 
初次接触仅依赖x坐标的ECDH协议总会感觉有些诡异,然而考虑到根据x坐标和曲线方程,基本上可以完全确定一个点有助于消除这种诡异的感觉.无法根据x坐标完全确定一个点的原因在于点P=(x,y)和-P = (x,-y)具有相同的x坐标. 这意味着在关于逆映射的商群的视角下,点的x坐标可以唯一表示商群中的元素.直观上理解,在关于逆映射的商群中,点P和点-P塌缩成同一个元素x(P)= x(-P). 更进一步, 点P和点-P的k倍乘的结果kP和k(-P)在该商群中也塌缩成同一个元素x(k(-P))= x(-kP) = x(kP).由此可以直观上理解,仅基于x坐标可以构建ECDH密钥交换协议.
 
在各种形式表示的椭圆曲线上都可以构建仅基于x坐标的运算,但是在蒙哥马利曲线上利用点群的代数结构(4阶点的存在)配合蒙哥马利阶梯算法(Montgomery Ladder Algorithm)所需的计算量更小并且常量时间实现更容易.这也是Bernstein选择蒙哥马利形式曲线的原因.除了底层的数学结构设计之外,X25519密钥交换协议也考虑了实际部署中经常遇到的问题,并基于对蒙哥马利曲线的观察进行了巧妙的规避,简化了X25519的实现和应用部署.
 
ECDH的实际应用中需要着重考虑的是对接收到的消息的检查.在典型的ECDH协议中,参与协议的双方都会接收到对方发来的临时公钥.为了保证安全(确保自己的私钥信息不会泄露),通常需要首先检查收到的点的合法性.如果收到的点是对方刻意构造的点,则对方有可能通过ECDH协议的交互过程窃取私钥信息.如果忽略点的检查则会导致small subgroup攻击或者invalid-curve攻击等. 类似的问题也存在于仅依赖x坐标的ECDH密钥交换协议之中.区别在于, 此时对公钥的合法性检查更为困难,相当于判定收到的公钥x根据曲线方程计算后得到的值是否是素数域上的二次剩余.由于域上的平方运算是2-to-1的映射,因此仅有一半的x值是合法的. 为了解决这个问题,X25519协议的设计创新性的将二次扩域上的椭圆曲线点群纳入考量.同时考虑基域和二次扩域上的两个椭圆曲线点群,则任意的底层素数域上的值都可以作为合法的公钥,更进一步在模运算的视角下,任意的32字节的数组都可以作为合法的公钥值,由此无需额外检查公钥的合法性.值得注意的是,虽然引入了二次扩域,但是所有的运算仍然是在底层的素数域上完成的,也即二次扩域的引入并没有增加计算的复杂性.由于离散对数问题在两个曲线点群中都是困难的,因此X25519密钥交换协议也是安全的.
 
虽然X25519协议的设计已经尽可能使得协议的使用不容易出错,但是Tendermint Core项目在基于X25519设计自己的加密通信协议时,由于协议设计的不当还是引入了安全隐患. Curve25519的细节, X25519协议的原理与运算规则以及Tendermint Core中X25519应用的详细分析,请戳[链接].

链接地址
https://github.com/longcpp/CryptoInAction/blob/master/intro-ed25519/190902-intro-x25519.pdf