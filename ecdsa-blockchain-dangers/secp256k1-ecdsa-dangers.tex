\documentclass{article}
\usepackage[UTF8, heading = false, scheme = plain]{ctex}

\usepackage{geometry}
\geometry{b5paper,left=2cm,right=2cm,top=2cm,bottom=2cm}

\usepackage{color}
\usepackage{amsfonts}
\usepackage{amsmath}

\linespread{1.5}

\usepackage[colorlinks,
            linkcolor=red,
            anchorcolor=blue,
            citecolor=green
            ]{hyperref}

\usepackage{listings}
\usepackage{fontspec}
\newfontfamily\monaco{Monaco}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{ %
  basicstyle=\footnotesize\monaco,       % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\footnotesize\monaco\color{gray},  % the style that is used for the line-numbers
  numbersep=5pt
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=4,                      % sets default tabsize to 2 spaces
  captionpos=t,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}

\usepackage{amssymb} 

\setlength{\parindent}{2em}

\renewcommand{\G}{\mathbb{G}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\F}{\mathbb{F}}

\newcommand{\Sbox}{\textsf{Sbox}}
\newcommand{\code}[1]{\lstinline!#1!}

%%%%%%%处理下划线：_%%%%%%%%%
\usepackage{underscore}
%%%%%%%处理下划线：_%%%%%%%%%

\setlength{\parindent}{2.1em}

\begin{document}

\title{ECDSA签名机制在区块链领域中的应用}
\author{longcpp \\ longcpp9@gmail.com}

\maketitle

\section{椭圆曲线secp256k1与secp256r1}

由于Bitcoin中的采纳,曾经未曾得到广泛部署的椭圆曲线secp256k1成为了大多数区块链项目中默认的椭圆曲线选择.
曲线secp256k1的名字来自于密码学标准文档SEC2~\cite{}~,其中``sec"是``Standards For Efficient Cryptography"缩写,
``p"表示椭圆曲线参数定义在有限域$\F_p$上, ``256"表示该有限域中元素的比特长度为256, 
``k"表示这是一条Koblitz曲线, 而``1"表示这是满足前述条件的第一条(实际上也是唯一的)推荐的曲线.
Koblitz曲线在密码学文献中通常指代定义在特征为2的有限域上$\F_{2^m}, m\in\Z$的椭圆曲线,
文献~\cite{}中泛化了Koblitz曲线的含义,也包括定义在大素数上$\F_p$上具备高效可计算自同态特性的椭圆曲线.

Satoshi在最开始选择secp256k1曲线的原因仍不可知,尤其是在当时得到广泛部署的是一条名为secp256r1椭圆曲线的背景之下.
原因可能是secp256k1曲线具备的高效可计算的自同态映射可以加速ECDSA签名验证过程的特性在区块链场景中尤为合适,
但是以OpenSSL为代表的各个密码学库的实现中并没有利用这一属性.
虽然libsecp256k1中的实现成功利用这一属性使得基于secp256k1的ECDSA签名验证速度达到了21000次每秒
(测试平台的芯片型号为 Intel(R) Core(TM) i7-6700HQ CPU), 速度上超过了OpenSSL 1.1版本中深度优化的基于secp256r1曲线的
ECDSA的12000次每秒的验签速度,最终证实了secp256k1曲线在ECDSA验签操作中的效率优势,但是在选定这条曲线时,
并没有相应的实现可以证实关于验签效率的推断.

然而后来的斯诺登泄露的文档中显示的NSA可能在NIST标准中的埋藏算法级后门的信息,尤其经过Dual_EC_DRBG~\cite{}~
事件验证之后, Satoshi当初的曲线选择在后来看来有了先见之明的意味. 
得到广泛部署的secp256r1曲线中的``r"表示曲线参数是从随机种子派生而来. 
secp256r1 (NIST P-256)曲线的参数是从随机种子
$$c49d3608 86e70493 6a6678e1 139d26b7 819f7e90$$
中派生而来, 而该随机种子的来源NIST并没有解释,鉴于Dual_EC_DRBG事件的教训,难免会有其中存在后门的疑虑
\footnote{\url{http://safecurves.cr.yp.to/rigid.html}}.
相比之下, secp256k1曲线的参数选择有合理的解释,也就有助于消除对存在算法级后门的担忧
\footnote{\url{https://bitcointalk.org/index.php?topic=289795.msg3183975\#msg3183975}}.
后续介绍基于secp256k1的ECDSA签名机制在区块链领域中的应用以及在区块链场景下的面临的特殊问题.

\section{基于椭圆曲线secp256k1的ECDSA签名}

定义在有限域$\F_p$上的曲线secp256k1的方程为$y^2 = x^3 + 7$,其中
\footnotesize
$$p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f.$$
\normalsize
椭圆曲线上的点的个数为$\#E(\F_p) = h \cdot n$,其中$h = 1$为余因子(Cofactor), $n$为$E(\F_p)$的最大素子群的阶:
\footnotesize
$$ n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141.$$
\normalsize
子群 $\G = \langle G \rangle$的基点$G$的坐标为:
\footnotesize
$$G_x = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798$$
$$G_y = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8$$
\normalsize
值得提及的是, $\G$的阶$n$是素数,也即$\F_n$是有限域,非零元构成的乘法群表示为$\F_n^*$.

假设待签名消息为$m$, 私钥为$d$, 公钥为$P=dG$, 哈希算法为$H: \{0,1\}^*\rightarrow\F_n^*$.
\textbf{ECDSA签名值$\sigma = (r,s), r, s \in \F_n^*$的计算过程}为: 
\begin{enumerate}
\item 选择随机数$k\in_R\F_n^*$, 计算$R = (x,y) = kG, x, y \in \F_p$, 计算$r = x\mod n \in \F_n^*$,
\item 计算消息$m$的哈希值$h=H(m)\in\F_n^*$, 计算 $s = k^{-1} (h + rd) \mod n$. 
\end{enumerate}
注意$k, r, s \in \F_n^*$,也即$k, r, s$均不得为0, 如果为0, 则重新选择$k$进行计算.

给定消息$m$, 公钥$P$, 签名值$\sigma = (r, s)$, \textbf{签名验证的过程}为:
\begin{enumerate}
\item  验证$r, s$确实是$\F_n^*$中的元素,也即$r, s \in [1, n-1]$, 否则签名值无效,
\item 计算哈希值$h=H(m)\in\F_n^*$,并计算$s\in\F_n^*$的逆$s^{-1}$,
\item  计算$R' = (x', y') = hs^{-1}G + rs^{-1}P$, 
\item 判断$R' \neq \mathcal{O}$,否则验签失败, 判断 $x' \mod n = r$, 相等则验签成功,否则验签失败.
\end{enumerate}
合法的签名能够验证通过是因为
$$R' = hs^{-1}G + rs^{-1}P = hs^{-1}G + rs^{-1}(dG) = s^{-1}(h+rd)G = kG = R.$$
上述基于曲线secp256k1的ECDSA签名机制,总共涉及3种数学结构上的计算:
有限域$\F_n$上加法和乘法运算(求逆运算可以由加法和乘法运算构造), $E(\F_p)$中的加法点群$\G$中点的加法运算(点的倍乘),
由于$\G$中的点的坐标为有限域$\F_p$中的元素,则点的加法运算中也涉及到有限域$\F_p$上的加法和乘法运算(求逆运算).
编码实现ECDSA签名机制时,需注意区分不同的运算,尤其要注意不要混淆有限域$\F_n$和$\F_p$上的运算.

\section{ECDSA签名机制应用中的安全隐患}

ECDSA签名机制在编码实现和应用时,特别是在区块链场景中应用时很容易引入安全问题,列举如下,随后依次介绍每个安全隐患的原理.
\begin{enumerate}
\item 如果$k$值泄露,则任何知道该随机数值的人可以使用该随机数产生签名值恢复私钥
\item 用相同私钥和$k$对两个消息进行签名,则任何人都可以通过两个签名值恢复出私钥
\item 两个用户使用相同的$k$分别对不同的消息进行签名,则任一方可推算出对方的私钥
\item 相同私钥和$k$同时用于ECDSA签名和Schnorr签名时,任何人都能够恢复出私钥
\item ECDSA签名值的可锻造性,会造成区块链网络的分裂
\item 签名值通常采用的DER编码由于编码值并不唯一也会造成区块链网络的分裂
\item 不需要提供签名消息的情况下,任何人可以根据任意签名值伪造对应私钥的签名值
\item 实现方面,侧信道攻击可以利用不安全的ECDSA签名实现窃取用于签名的私钥
\end{enumerate}

\subsection{随机数$k$值泄露导致私钥泄露}

签名过程中使用的随机数$k\in\F_n^*$一定要及时删除以免泄露.
这是因为知道随机数$k$的任何人,都可以根据签名值$\sigma=(r,s)$计算出相应的生成该签名值的私钥$d$.
随机数$k$的值与签名值$\sigma=(r,s)$之间的对应关系可以根据等式$x = (kG)_x \mod n = r$来进行判断.
由于$k$, $r$以及$h=H(m)$已知,则可以根据下面的公式计算私钥$d$:
$$s=k^{-1}(h+rd) \mod n \rightarrow ks = (h + rd)\mod n \rightarrow d = r^{-1}(ks - h)\mod n.$$

基于上述理由,在通过随机数发生器(Random Number Generator, RNG)生成随机数$k$的时候,
首先要确保选用的RNG生成的随机数的质量, 然后要确保生成的随机数没有被记录下来, 
还要确认RNG实现的安全性(生成$k$的能量消耗等侧信道信息不会泄露$k$的值),最后在使用完随机数$k$之后要将其及时删除.

\subsection{同一用户重用随机数$k$导致私钥泄露}

如果同一个用户使用自己的私钥对不同的消息进行签名时,使用了相同的$k$值,则任何人可以根据消息和签名值推算出用户的私钥.
假设用户用私钥$d$和$k$对消息$m_1$和$m_2$进行签名,生成了签名值$\sigma_1=(r, s_1)$和$\sigma_2=(r, s_2)$,
可以看到两个签名值的$r$部分相同,这是因为使用了相同的$k$,而$r = (kG)_x \mod n$, 根据签名计算过程则有:
\begin{equation}\nonumber
\left\{
\begin{array}{lll}
s_1 = & k^{-1}(h_1 + rd) \mod n, & h_1 = H(m_1)\\
s_2 = & k^{-1}(h_2 + rd) \mod n, & h_2 = H(m_2)
\end{array}
\right.
\end{equation}
上面的方程组中,可以看到未知的变量仅有$k$和$d$,两个方程两个未知量,通过解方程组可以推算出私钥$d$.
根据上面的方程组就有
\begin{equation}\nonumber
\left\{
\begin{array}{ll}
k = & s_1^{-1} (h_1 + rd) \mod n \\
k = & s_2^{-1} (h_2 + rd) \mod n
\end{array}
\right.
\ 
\rightarrow
\ 
\dfrac{h_1+rd}{s_1^{-1}} = \dfrac{h_2+rd}{s_2^{-1}} \mod n
\end{equation}
根据$s_2(h_1+rd) = s_1(h_2+rd)\mod n$,可以推断出私钥
$$d = \dfrac{s_2h_1 - s_1h_2}{(s_1-s_2)r} \mod n.$$

\subsection{不同用户重用随机数$k$导致私钥泄露}

前一小节论述了同一个用户签名时重用随机数$k$的安全隐患, 然而如果两个用户之间重用了随机数$k$, 同样也会私钥泄露的隐患.
如果两个用户Alice和Bob在用自己的私钥签名时,选用了同样的随机数$k$,
则Alice可以根据签名值推算出Bob的私钥, Bob也可以根据签名值推算出Alice的私钥.
假设Alice的私钥为$d_1$, 要签名的消息为$m_1$, 选用随机数$k$时计算的签名值为$\sigma_1 = (r, s_1)$,
Bob的私钥为$d_2$, 要签名的消息为$m_2$, 选用同样随机数$k$时计算的签名值为$\sigma_2 = (r, s_2)$.
则根据签名值的计算过程有
\begin{equation}\nonumber
\left\{
\begin{array}{lll}
s_1 = & k^{-1}(h_1 + rd_1) \mod n, & h_1 = H(m_1)\\
s_2 = & k^{-1}(h_2 + rd_2) \mod n, & h_2 = H(m_2)
\end{array}
\right.
\end{equation}
根据上面的方程组就有
\begin{equation}\nonumber
\left\{
\begin{array}{ll}
k = & s_1^{-1} (h_1 + rd_1) \mod n \\
k = & s_2^{-1} (h_2 + rd_2) \mod n
\end{array}
\right.
\ 
\rightarrow
\ 
\dfrac{h_1+rd_1}{s_1^{-1}} = \dfrac{h_2+rd_2}{s_2^{-1}} \mod n
\end{equation}
则有$s_2(h_1+rd_1) = s_1(h_2+rd_2) \mod n$.
在Alice看来,等式中未知的变量只有Bob的私钥$d_2$, Alice可以计算Bob私钥:
$$d_2 = \dfrac{s_2h_1 - s_1h_2 + s_2rd_1}{s_1r} \mod n,$$
而在Bob看来,等式中未知的变量只有Alice的私钥$d_1$, Bob可以计算Alice的私钥:
$$d_1 = \dfrac{s_1h_2 - s_2h_1 + s_1rd_2}{s_2r} \mod n.$$

\subsection{ECDSA与Schnorr共用$k$导致私钥泄露}

前面两个小节可以看到,同一用户重用$k$,不同用户重用$k$都会导致用于签名的私钥泄露的问题.
然而除了用户自己/用户之间重用$k$之外,如果不同的签名机制在签名时重用了$k$也同样会导致私钥泄露.
Bitcoin和Bitcoin Cash网络中正在围绕在链上采纳Schnorr签名而做大量的准备活动,
其中Bitcoin Cash已经在19年5月份的网络协议升级中为交易签名过程添加Schnorr签名机制.

首先介绍定义在椭圆曲线secp256k1上的Schnorr签名机制可以与ECDSA签名机制共用相同的公私钥对,
也即用于ECDSA签名的公私钥对$d\in\F_n^*, Q=dG\in\G$,同时也可以是Schnorr签名机制的公私钥对.
假设待签名消息为$m$,有哈希函数$H: \{0,1\}^*\rightarrow \F_n^*$, 
则\textbf{Schnorr签名$\sigma=(R,s), R\in \G, s\in\F_n^*$的计算过程}为:
\begin{enumerate}
\item 选取随机数$k\in_R\F_n^*$, 计算 $R=(x,y)=kG$,
\item 计算哈希值$h = H(R||P||m)\in\F_n^*$, 计算$s=r+hd \mod n \in \F_n^*$.
\end{enumerate}
给定消息$m$,公钥$P$, Schnorr签名值$\sigma=(R,s)$, \textbf{Schnorr签名验证过程}为:
\begin{enumerate}
\item 验证$R$确实是$\G$中的元素,验证$s$确实是$\F_n^*$中的元素,否则验签失败,
\item 计算哈希值$h = H(R||P||m)\in\F_n^*$,
\item 计算$R+hP$并验证是否与$sG$相等,如果相等验签通过,否则验签失败.
\end{enumerate}
合法的签名值能够验证通过是因为:
$$
sG = (k+hx)G = kG + hxG = R + h(dG) = R + hP.
$$
值得提及的是Schnorr签名还有另外一种变体,此处仅介绍Bitcoin和Bitcoin Cash网络中采用的Schnorr签名机制,
对于展示ECDSA和Schnorr签名共用$k$导致私钥泄露的问题来说已经足够.

用$d, P$表示ECDSA和Schnorr签名所共用的公私钥对, ECDSA签名用随机数$k$对消息$m_1$的签名值为$\sigma_1 = (r, s_1)$,
Schnorr签名用相同的随机数对消息$m_2$的签名值为$\sigma_2 = (R, s_2)$,下面展示如何通过签名值恢复私钥$d$.
根据签名计算规则有
\begin{equation}\nonumber
\left\{
\begin{array}{lll}
s_1 = & k^{-1}(h_1 + rd) \mod n, & h_1 = H(m_1)\\
s_2 = & k + h_2d \mod n, & h_2 = H(R||P||m_2)
\end{array}
\right.
\end{equation}
则有$k = s_2 - h_2d\mod n$,带入上述方程组的第一个等式得到
$$
s_1 =  (s_2 - h_2d)^{-1}(h_1 + rd) \mod n \rightarrow d = \dfrac{s_1s_2 - h_1}{s_1h_2 + r} \mod n.
$$

\subsection{ECDSA签名值的可锻造性问题}



\subsection{ECDSA签名值DER编码的不唯一问题}

\subsection{不需要提供签名值对应的消息$m$时可伪造签名值}

\subsection{不安全的ECDSA签名实现私钥泄露}


\begin{thebibliography}{99}

\bibitem{ecdsa-side-channel}
Genkin, Daniel, Lev Pachmanov, Itamar Pipman, Eran Tromer, and Yuval Yarom. "ECDSA key extraction from mobile devices via nonintrusive physical side channels." In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pp. 1626-1638. ACM, 2016.

\end{thebibliography}

\end{document}