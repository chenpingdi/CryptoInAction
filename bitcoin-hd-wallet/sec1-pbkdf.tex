
\section{基于口令的密钥派生函数}

PBKDF用来从一个较短的便于记忆的口令(Passphrase/Password)派生出密码学方案中使用的密钥.
PBKDF的输入除了口令之外,通常还有一些其他的输入参数, 如盐值(Salt), 迭代次数(Iteration Count)等,
这些参数用来引入更多的熵值(Entropy)或者用于调整一次PBKDF计算所需的计算量.
PBKDF通常是计算密集型的,计算需要消耗较为可观的计算量.
从口令派生密码学方案中使用的密钥时,由于只需要进行一次操作,通过调整参数,可以在用户体验和计算量之间进行权衡.
而对暴力攻击，攻击者可能需要执行上亿次计算，因此它大幅增加了攻击者的计算难度。
并且此类算法支持随着计算机硬件的发展做对计算难度进行灵活的调整，使用起来十分方便。

\subsection{PBKDF2}
PBKDF2全称为Password-Based Key Derivation Function 2，在PKCS\#5
中取代了输出长度不大于160比特的PBKDF1作为该规范推荐的密钥派生函数。
BIP39协议使用该函数从助记词组派生一个随机串，该随机串用作BIP32 HD(Hierarchical Deterministic)
钱包中生成主密钥对的seed。  PBKDF2最早被包含在PKCS\#5中发表，后来该规范又被IETF以RFC 
2898\footnote{
RFC2898: PKCS \#5: Password-Based Cryptography Specification Version 2.0.
\url{https://tools.ietf.org/html/rfc2898}}重新发表。在2017年发布的RFC8018中，仍然建议用它来做password hashing。

在PBKDF中，由于用户的passphrase取值空间一般较小，攻击者在进行暴力攻击时比较容易。
Salt作为一段均匀随机分布的比特串，不需要保密，目的是为了增加攻击者的搜索空间。
同时当salt足够长时（如64bit），攻击者无法通过预计算存储相应的计算结果，从而降低了攻击的可行性。

\subsection{Scrypt算法}
Scrypt算法由Colin Percival设计，与PBKDF2相比，该算法在执行时对内存的消耗较高，
限制了利用硬件并行实现来划分搜索空间从而降低暴力攻击复杂度的可行性，
以此来抵抗大规模的专用硬件攻击（即使用ASIC来加速暴力攻击的计算过程）。
BIP38协议使用Scrypt算法作为密钥派生函数，从passphrase派生AES的加密密钥。 
 
Scrypt算法定义如\ref{Scrypt},用户可以根据当前CPU、内存的发展情况、以及要求的并行度对
N，r，p参数进行调节，从而调整算法对CPU/内存的消耗。

其中，scryptROMix\ref{scryptROMix}算法用来产生一个expensive-cost 的salt，Scrypt算法对内存的消耗即来源于它。在执行时，它会产生一组长度为N的伪随机比特串（如下，$V[i]$），
同时以一种伪随机的顺序对该比特串进行访问，这就导致攻击者必须有足够的内存来存储它。
并且该比特串的计算是比较费时的，因此攻击者经过对时间和空间进行权衡的结果，
要么是对内存资源要求不高但运行很慢，要么是效率较高但内存消耗较大。

\begin{algorithm}[tbp]\footnotesize
\caption{PBKDF2}
\label{PBKDF2}
  	\begin{algorithmic}[1]
	    \REQUIRE ~~\\ 
	    PRF: pseudorandom function of two parameters with output length hLen (Optional)\\
	    Password: the master password from which a derived key is generated\\
	    Salt: a sequence of bits, known as a cryptographic salt\\
	    c: the number of iterations desired\\
	    dkLen: the desired bit-length of the derived key\\
	    \ENSURE ~~\\
	    DK: the generated derived key\\
	    \STATE If $dkLen > (2^{32} - 1) * hLen$, output "derived key too long" and stop;
	    \STATE Let $l$ be the number of $hLen$-octet blocks in the derived key,
	     rounding up, and let $r$ the number of octets in the last block:  
			$$l =\lceil (dklen/hlen) \rceil $$ 
			$$r =dklen -(l-1)*hlen;$$		
		\STATE For each block of the derived key, apply the function $F$ defined 
		below to the password $P$, the salt $S$, 
	  	the iteration count $c$, and the block index to compute the block:
			$$T_1=F(P,S,c,1)$$
			$$T_2=F(P,S,c,2)$$
			$$\cdots$$
			$$T_l=F(P,S,c,l)$$ 
		where $F$ is defined as: $F(P,S,c,i)=U_1 \oplus U_2  \cdots \oplus U_c$ and
			$$U_1=PRF(P,S||INT(i))$$ 
			$$U_2=PRF(P,U_1)$$
			$$\cdots$$
			$$U_c=PRF(P,U_{c-1})$$
		Here, $INT (i)$ is a four-octet encoding of the integer i, most significant octet first.
		\STATE Concatenate the blocks and extract the first $dkLen$ octets to 
		produce a derived key $DK$:  
			$$DK=T_1||T_2||\cdots|| T_l<0,\cdots r-1>$$
		\RETURN the derived key $DK$.		
    \end{algorithmic}
\end{algorithm}
 

\begin{algorithm}[tbp]\footnotesize
\caption{Scrypt}
\label{Scrypt}
  	\begin{algorithmic}[1]
	    \REQUIRE ~~\\ 
	    Passphrase, the password string.\\
		Salt, a sequence of bits, known as a cryptographic salt.\\
		N, CPU/Memory cost parameter, must be larger than 1, a power of 2,
		 and less than $2^{(128 * r / 8)}$.\\
		r, Block size parameter.\\
		p, Parallelization parameter, a positive integer less than or equal 
		to $((2^{32}-1) * hLen) / MFLen$ where $hLen$ is 32 and $MFlen$ is $128 * r$.\\
		$dklen$, Intended output length in octets of the derived key; 
		a positive integer less than or equal to $(2^{32} - 1) * hLen$ where $hLen$ is 32.\\
	    \ENSURE ~~\\
	    DK: the generated derived key\\
	    \STATE Initialize an array $B$ consisting of $p$ blocks of $128 * r$ octets each:\\
			$B[0]||B[1]||\cdots B[p-1]=PBKDF2-HMAC-SHA256(P,S,1,p*128*r)$
		\FOR{$i=0$ to $p-1$} 
			\STATE $B[i]= scryptROMix(r,B[i],N)$   
		\ENDFOR 
		\STATE $DK=PBKDF2-HMAC-SHA256(P,B[0]||B[1]||\cdots B[p-1],1,dklen)$
		\RETURN the derived key $DK$.		
    \end{algorithmic}
\end{algorithm}
 
\begin{algorithm}[tbp]\footnotesize
\caption{scryptROMix}
\label{scryptROMix}
  	\begin{algorithmic}[1]
	    \REQUIRE ~~\\ 
	    r, Block size parameter.\\
		B, Input octet vector of length $128 * r$ octets.\\
		N, CPU/Memory cost parameter, must be larger than 1,
		 a power of 2, and less than $2^{(128 * r / 8)}$.\\
		Integerify($B[0]||B[1]||\cdots B[2*r-1]$ ), 
		the result of intepreting $B[2*r-1]$ as a little-endian integer.\\
	    \ENSURE ~~\\
	    B', Output octet vector of length $128 * r$ octets.\\
	    \STATE $X = B$
		\FOR{$i = 0$ to $N - 1$}  
			\STATE $V[i]=X$  
			\STATE $X=scryptBlockMix(X)$  
 		\ENDFOR 
		\FOR{$i=0 to N-1$}  
			\STATE $j=Integerify(X)$ mod $N$  
			\STATE $T=X \oplus V[j]$  
			\STATE $X=scryptBlockMix(T)$  
		\ENDFOR
		\RETURN $B'=X$	
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}[tbp]\footnotesize
\caption{scryptBlockMix}
  	\begin{algorithmic}[1]
	    \REQUIRE ~~\\ 
	     r, Block size parameter\\
 		$B[0]||B[1]||\cdots B[2*r-1]$, input octet string (of size $128 * r$ octets), 
 		treated as $2 * r 64$-octet blocks, where each element in $B$ is a 64-octet block.\\
 		Salsa refers to Salsa20/8, which is reduced round function of Salsa20 Core.\\
	    \ENSURE ~~\\
	    $B'[0]||B'[1]||\cdots B'[2*r-1]$, output octet string.\\
	    \STATE $X = B[2*r-1]$
		\FOR {$i = 0$ to $2*r - 1$} 
			\STATE $T=X \oplus B[i]$  
			\STATE $X=Salsa(T)$  
			\STATE $Y[i]=X$
		\ENDFOR 
		\RETURN $B'=(Y[0],Y[2],\cdots,Y[2*r-2],Y[1],Y[3],\cdots, Y[2*r-1])$
    \end{algorithmic}
\end{algorithm}

\begin{lstlisting}[language = c, caption = Salsa20/8, label=lst-salsa20core][h]
#define R(a,b) (((a) << (b)) | ((a) >> (32 - (b)))) 
void salsa20_word_specification(uint32 out[16],uint32 in[16]) 
{

	int i; 
	uint32 x[16]; 
	for (i = 0;i < 16;++i) x[i] = in[i]; 
	for (i = 8;i > 0;i -= 2) { 
		x[ 4] ^= R(x[ 0]+x[12], 7); x[ 8] ^= R(x[ 4]+x[ 0], 9);
		x[12] ^= R(x[ 8]+x[ 4],13); x[ 0] ^= R(x[12]+x[ 8],18); 
		x[ 9] ^= R(x[ 5]+x[ 1], 7); x[13] ^= R(x[ 9]+x[ 5], 9); 
		x[ 1] ^= R(x[13]+x[ 9],13); x[ 5] ^= R(x[ 1]+x[13],18); 
		x[14] ^= R(x[10]+x[ 6], 7); x[ 2] ^= R(x[14]+x[10], 9); 
		x[ 6] ^= R(x[ 2]+x[14],13); x[10] ^= R(x[ 6]+x[ 2],18); 
		x[ 3] ^= R(x[15]+x[11], 7); x[ 7] ^= R(x[ 3]+x[15], 9); 
		x[11] ^= R(x[ 7]+x[ 3],13); x[15] ^= R(x[11]+x[ 7],18); 
		x[ 1] ^= R(x[ 0]+x[ 3], 7); x[ 2] ^= R(x[ 1]+x[ 0], 9); 
		x[ 3] ^= R(x[ 2]+x[ 1],13); x[ 0] ^= R(x[ 3]+x[ 2],18); 
		x[ 6] ^= R(x[ 5]+x[ 4], 7); x[ 7] ^= R(x[ 6]+x[ 5], 9); 
		x[ 4] ^= R(x[ 7]+x[ 6],13); x[ 5] ^= R(x[ 4]+x[ 7],18); 
		x[11] ^= R(x[10]+x[ 9], 7); x[ 8] ^= R(x[11]+x[10], 9); 
		x[ 9] ^= R(x[ 8]+x[11],13); x[10] ^= R(x[ 9]+x[ 8],18); 
		x[12] ^= R(x[15]+x[14], 7); x[13] ^= R(x[12]+x[15], 9); 
		x[14] ^= R(x[13]+x[12],13); x[15] ^= R(x[14]+x[13],18);

	}
 	for (i = 0;i < 16;++i) out[i] = x[i] + in[i];

}
\end{lstlisting}

